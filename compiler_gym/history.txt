Проблема автоматической настройки компиляторов с целью улучшения оптимизации программ была сформулирована практически одновременно с появлением оптимизирующих компиляторов, а задачи предсказания лучшего набора (1) и лучшей последовательности оптимизирующих трансформаций (2) и возможные способы их решения без привлечения машинного обучения были сформулированы в конце 70-х гг XX века [1,leverett].   


Подавляющее большинство исследований и инженерных практик сосредоточено на цели повышения производительности, традиционно называемой оптимизацией.

Одно из фундаментальных преимуществ развития компиляторных приложений на основе машинного обучения заключается в том, что оно вынуждает применять эмпирический подход к конструкции компилятора. Новые модели должны быть основаны на эмпирических данных, которые затем могут быть проверены экспертно. Этот цикл – эксперимент – гипотеза – испытание [] хорошо известен в физических науках, но является относительно новым для конструирования компиляторов.

-- Адаптивная и не-итеративная компиляция --
Адаптивная, или управляемая профилированием, оптимизация программ является альтернативой итеративной компиляции, и реализована в значительной части компиляторов общего назначения. Подход основан на профилировании исследуемой программы на отдельных сценариях, с последующим использованием собранных данных о для определения наилучших оптимизаций. Данный подход позволяет достичь отличных результатов на спрофилированных, но может давать непредсказуемые результаты на остальных сценариях, а также является менее прозрачным для исследователя, нежели итеративная компиляция. Трансфер знаний в случае адаптивной компиляции крайне затруднён.

Альтернативный к вышеупомянутым подход не-итеративной компиляции, предсказывающей всю цепочку оптимизаций, до последего времени не получил широкого развития, но решений, основанных преимущественно на обучении с учителем, .
--
Так или иначе, в последние два десятиления основные усилия исследователей были направлены на преодоление проблемы отсутствия трансфера знаний между экспериментами и на ускорение поиска по пространству оптимизации, с применением различных приближённых методов поиска.
--

Развитие методов машинного обучения в последнее десятилетие привело к совершенствованию и изобретению новых подходов к обозначенным задачам, в совокупности с непрерывной доработкой компиляторных средств и инфраструктур. В первую очередь, были разработаны подходы и инструменты, ускоряющие итеративную компиляцию за счёт выделения подпространства оптимизации, по которому осуществляется перебор [cgo06], и предоставляющие методологическую и инфраструктурную базу для проведения экспериментов с авто-настройкой компиляторов различными способами [,милепост]. Ряд работ был посвящён предсказанию производительности программы после применения соответствующей трансофрмации [-]. Ниже приведён краткий обзор различных подходов к предсказанию оптимальной последовательности трансформаций на основе машинного обучения. 

Обучение с учителем.
Основным фактором, затрудняющим применение обучения с учителем в данной области, является требование подготовки обучающих выборок: в виду того, что данные и сценарии использования программы в общем случае могут не поддаваться предсказаниям на этапе компиляции, сбор огромной обучающей выборки может оказаться бесполезным для различных задач и сценариев. К примеру, обучение модели по результатам производительности на одной архитектуре может быть не переносимо н другую. Тем не менее, было разработано множество решений, использующих разлиные подходы обучения с учителем: Байесовские сети [,], деревья принятия решения и случайные леса [], обучение метрики [], графовые ядра [], иные методы []. В данной области просматривается тренд интеграции разрабатываемых решений с рекомендательными системами.

Обучение без учителя.
Обучение без учителя в данной области представлено методами кластеризации, позволяющими выделить значимые кластеры трансформаций, которые должны быть упорядочены в подпоследовательности для достижения прироста производительности оптимизируемой программы. Также важность кластеризации обусловлена существенным уменьшением пространства оптимизации. В исследовании [] предложена методология ускорения обучения за счёт применения кластеризации после снижения размерности исходного пространства оптимизации. В работах [170, 171] представлено решение задачи упорядочивания трансформаций с помощью метода выбора, основанного на кластеризации для группировки сходных функций. Следующим широко применяемым в данной задаче классом алгоритмов оптимизации является класс эволюционных, в первую очередь, генетических алгоритмов. Купер и др. [69, 70] решили проблему размера кода генерируемых бинарных файлов с помощью генетического алгоритма, сравнили результаты с итеративным поиском оптимальных последовательностей трансформаций, и пришли к выводу, что для задачи уменьшения размера кода генетические алгоритмы дают результаты, сопоставимые с итеративным подходом при большом числе повторений. Агаков и др. [] адаптировали ряд моделей ускорения исследования пространства оптимизации при итеративной компиляции посредством применения оптимизации с оракулом, и добились достаточно высоких результатов на компиляторе GCC для Intel x86. В целом, в данном направлении наблюдается активность, в основном всязанная с апробацией разработанных способов на новые задачи и компиляторные инфраструктуры. Также следует отметить, что генетические алгоритмы используются в ряде других подходов в качестве референсных решений.

Обучение с подкреплением.
В данном направлении наблюдается наибольшая активность, вследствие общего развития инструментов обучения с подкреплением, а также естественностью трактовки задачи поиска оптимальных последовательностей трансформаций как последовательности шагов агента, получающего награду как приращение целевой метрики -- производительности, размера файла и пр. Состоянием при этом является сама частично оптимизированная программа, а пространством наблюдения -- результат её характеризации. Принятие решения, какую трансформацию применять, осуществляется на основании наблюдения и, возможно, предыстории. Экспериментально установлено [Autophase, CompilerGym], что обучение с подкреплением на данных задачах позволяет достигать результатов, сопоставимых с результатами генетических алгоритмов за существенно меньшее число повторений. Кроме того, репрезентативность характеристик программы также существенно влияет на скорость сходимости и качество получаемых результатов. Наилучшие результаты были получены с алгоритмами семейства актор-критик (A3C, A2C) и с учётом предыстории []. Комплексное сравнение различных алгоритмов машинного обучения, в особенности, обучения с подкреплением, было проведено в 2022 г. Каммингсом и др. [] с использованием разработанного предварительного инструмента CompilerGym, поддерживающего различные компиляторные окружения, алгоритмы оптимизации и представления программ. Авторами отмечена важность развития приложений обучения с подкреплением в компиляторных инфраструктурах и выделены основные направления развития, среди которых -- совершенствование представлений программ, доработка компиляторов с целью поддержания интерфейсов для задач машинного обучения, учёт параметров оптимизационных проходов, интеграция машинного обучения в другие задачи компиляторной оптимизации, в особенности, замена эвристик принятия решения на методы машинного обучения. В области последнего направления уже существуют инструменты, основанные на обучении с подкреплением -- MLGO [] и NeuroVectorizer []. Тем не менее, интеграция процесса подбора наилучших параметров трансформаций в поиск наилучших последовательностей до сих пор является открытой проблемой [].

В зависимости от способа предсказания, подходы к решению задачи поиска оптимальной последовательности применения трансформаций (2) делятся на 2 типа -- итеративный, когда в условии совершения некоторых трансформаций предсказывается следующая, и глобальный, в рамках которого происходит предсказание всей последовательности либо подпоследовательности []. Первый тип проще реализовать на практике [,], однако данный тип имеет склонность сходимости к локальным оптимумам. Второй тип теоретически не имеет недостатков первого, однако существенно сложнее в реализации. Кроме того, второй тип подразумевает меньшее количество промежуточных измерений, что, в виду необходимости профилирования для некоторых задач, делает данный подход предпочтительным, хотя и более сложным в для практики. Современная методология итеративного [] и глобального [] подходов была сформулирована Ашоури и др. в 2016 и 2017 году соответственно. 

Характеризация кода.
Выбор метода представления, или характеризации оптимизируемой программы является ключевым вопросом для применения вышеупомянутых методов машинного обучения в связи с необходимостью выделения репрезентативных признаков для подачи на вход модели. Установлено, что выбор достаточно точно характеризующего программу вектора признаков способен как улучшать результаты предсказания, так и увеличивать скорость сходимости на 1-2 порядка по сравнению с методами менее точной характеризации [,]. В то же время, построение нерепрезентативного вектора большой размерности может существенно ухудшать результаты, замедлять и даже останавливать обучение. Производный вектор признаков должен быть достаточно репрезентативным, и разные приложения не должны иметь один и тот же вектор признаков, кроме того, если трансформация изменяет некоторый промежуточный код, это также должно быть отражено в изменении вектора признаков. Методы характеризации традиционно разделяются на статические, динамические и гибридные.

Статическая характеризация кода.
На данный момент наиболее широкое распространение получили методы на основе агрегации характеристик составляющих исходного или промежуточного кода, к примеру построение частотного словаря типов инструкций, либо более продвинутый метод сбора счетчиков различных характеристик программы -- числа базовых блоков, среднего числа инструкций в базовом блоке, количестве ветвлений и др. []. Программная семантика при таком подходе не учитывается, что является недостатком. Набирающее в последнее время популярность направление приложений методов обработки естественных языков к анализу кода обусловило построение ряда методов характеризации программы как эмбеддинга от последовательностей токенов -- code2vec, CodeBERT и др. Данные методы недостаточно качественно характеризуют семантику программ по построению. Исключением является inst2vec [], который выучивает граф-структурированный контекст программных единиц, что позволяет учесть потоки данных. В отличие от других решений из обработки естественных языков, для inst2vec авторы хотя бы приблизительно оценивают операционную семантику получаемого представления, что позволяет оценивать его практические свойства. К сожалению, данный метод не чувствителен к информации от типах и о порядке аргументов инструкций. Следующим классом методов являются граф-структурированные методы характеризации, представляющие данные об отношениях на графах потоков управления, данных, вызовов, граф-структурированную информацию о типах и т.д. []. Так как операционную семантику, как правило, явно не моделируют, исследователи опираются преимущественно на эвристический выбор и на экспериментальные и статистические результаты, согласно которым учёт граф-структурированной информации, извлеченной из программы, позволяет довольно точно учесть основные элементы её семантики. В последние годы интерес к данному направлению явно возрос, в связи с развитием методов графовых нейросетей и эмбеддингов граф-структурированных данных. В 2020 и 2021 гг. были представлены два метода -- ProGraML [] и IR2Vec [], ProGraML строит  глобальный граф потоков данных, потока управления, вызовов и типов из промежуточного представления LLVM, с последующим обучением представления графовой нейросетью передачи сообщений, демонстрирующий выдающиеся результаты по решению различных задач, возникающих в статическом анализе кода и компиляторной оптимизации [], однако имеет существенный недостаток низкой производительности и масштабируемости. Второй метод, IR2Vec [], основан на иерархическом построении эмбеддингов программ как суперпозиций программных компонент: инструкций, аргументов, типов, достижимых определений, базовых блоков, функций и единицы трансляции, используя предобученный словарь элементарных единиц программы. Данный метод достаточно точно учитывает потоки данных, однако нечувствителен к перестановкам базовых блоков в функции в виду коммутативности операции сложения, что затрудняет его использование в ряде приложений. К тому же, данный метод на практике имеет недостатки с масштабируемостью на относительно большие единицы трансляции []. 

Динамическая характеризация кода.
Разделяют архитектурно-зависимую и архитектурно-независимую характеризацию []. При первом подходе, как правило, используют модель-специфичные счетчики производительности аппаратного обеспечения, на котором программа профилируется. При втором подходе используют агрегацию данных, известных только на этапе исполнения, например, количество фактических вызовов функции или итераций циклов. Динамическая характеризация, как правило, в чистом виде используется в классических подходах к итеративной компиляции, а также для построения пространства наград при обучении с подкреплением [].

Гибридная характеризация кода.
Как правило, гибридная характеризация заключается в расширении результатов статической характеризации данными профилирования исследуемой программы. Показано, что гибридная характеризация способна приводить к существенному улучшению результатов и к росту скорости сходимости. Инструменты адаптивной компиляции, как правило, основаны именно на таком типе характеризации.

Текущее состояние исследований по теме характеризации кода.
На момент планирования проекта, вопрос построения одновременно качественного и масштабируемого способа характеризации программ общего назначения для машинного обучения представляет открытую проблему, а на практике, как правило, используется экспертный отбор признаков для каждой отдельной задачи [].

Построение пространства шагов.
Классически, пространство шагов для итеративного решения задачи (2) представляет множество отдельных оптимизационных проходов []. С целью ускорения методов поиска, были предложены и реализованы подходы, основанные на использовании граф-структурированного пространства шагов [], где проходы упорядочены с целью получения большего выигрыша от применения упорядоченных подпоследовательностей. Построение графа может производиться либо на основании некоторых эвристик, либо на основании коллаборативной фильтрации и упорядочиванию близких по некоторой программной метрике подпоследовательностей, извлечённых из изначального графа либо из корпуса экспертно составленных конфигурационных файлов []. Пространство шагов строится путём разбиения на пути графа упорядоченных оптимизаций (авторский перевод термина "order-dependency graph"), генерируемого либо из проходов, включенных в  "уровень оптимизаций" -O2,-O3, и др., либо из экспертных данных. Подходы к разбиению различны и основаны, как правило, на эвристиках по анализу характеристик графа [].

-- Заключение --
Развитие направления обучения с учителем в данной области существенно ограничено 



Z. Wang and M. O’Boyle, "Machine Learning in Compiler Optimization," in Proceedings of the IEEE, vol. 106, no. 11, pp. 1879-1901, Nov. 2018, doi: 10.1109/JPROC.2018.2817118.



Bruce W Leverett et al.. 1979. An overview of the production quality compiler-compiler project. Carnegie Mellon University, Department of Computer Science

M Haneda. 2005. Optimizing general purpose compiler optimization. Proceedings of the 2nd conference on Computing frontiers (2005), 180–188. http://dl.acm.org/citation.cfm?id=1062293

F. Agakov, E. Bonilla, J.Cavazos, B.Franke, G. Fursin, M. O’Boyle, J. Thomson, M. Toussaint, and C. Williams, “Using machine learning to focus iterative optimization,” in CGO ’06: Proceedings of the International Symposium on Code Generation and Optimization. Washington, DC, USA: IEEE Computer Society, 03 2006, pp. 295–305. [Online]. Available: http://www.anc.ed.ac.uk/machine-learning/colo/cgo06.pdf

J Thomson, M O’Boyle, G Fursin, and B Franke. 2009. Reducing training time in a one-shot machine learning-based compiler. International Workshop on Languages and Compilers for Parallel Computing (2009), 399–407. http://link.springer.com/10.1007

Amir Hossein Ashouri, Vittorio Zaccaria, Sotirios Xydis, Gianluca Palermo, and Cristina Silvano. 2013. A framework for Compiler Level statistical analysis over customized VLIW architecture. In VLSI-SoC. 124–129. DOI:http://dx.doi.org/10.1109/VLSI-SoC.2013.6673262

LGA Martins and R Nobre. 2016. Clustering-Based Selection for the Exploration of Compiler Optimization Sequences. ACM Transactions on Architecture and Code Optimization (TACO) 13, 1 (2016), 28. http://dl.acm.org/citation.cfm?id=2883614

Luiz GA Martins, Ricardo Nobre, Alexandre CB Delbem, Eduardo Marques, and João MP Cardoso. 2014. Exploration of compiler optimization sequences using clustering-based selection. In ACM SIGPLAN Notices, Vol. 49. ACM, 63–72

KD Cooper, PJ Schielke, and D Subramanian. 1999. Optimizing for reduced code space using genetic algorithms. ACM SIGPLAN Notices (1999). http://dl.acm.org/citation.cfm?id=314414

KD Cooper, D Subramanian, and L Torczon. 2002. Adaptive optimizing compilers for the 21st century. The Journal of Supercomputing (2002). http://link.springer.com/article/10.1023/A:1015729001611

Felix Agakov, Edwin Bonilla, John Cavazos, Björn Franke, Grigori Fursin, Michael FP O’Boyle, John Thomson, Marc Toussaint, and Christopher KI Williams. 2006. Using machine learning to focus iterative optimization. In Proceedings of the International Symposium on Code Generation and Optimization. IEEE Computer Society, 295–305.

G. Fursin, C. Miranda, O. Temam, M. Namolaru, E. Yom-Tov, A. Zaks, B. Mendelson, P. Barnard, E. Ashton, E. Courtois, F. Bodin, E. Bonilla, J. Thomson, H. Leather, C. Williams, and M. O’Boyle, “Milepost gcc: machine learning based research compiler,” in Proceedings of the GCC Developers’ Summit, June 2008.

C.-K. Luk, S. Hong, and H. Kim, “Qilin: Exploiting parallelism on heterogeneous multiprocessors with adaptive mapping,” in Proceedings of the 42nd Annual IEEE/ACM
International Symposium on Microarchitecture, ser. MICRO 42. New York, NY, USA: Association for Computing Machinery, 2009, p. 45–55. [Online]. Available:
https://doi.org/10.1145/1669112.1669121

E. Park, L.-N. Pouche, J. Cavazos, A. Cohen, and P. Sadayappan, “Predictive modeling in a polyhedral optimization space,” in Proceedings of the 9th Annual IEEE/ACM International Symposium on Code Generation and Optimization, ser. CGO ’11. USA: IEEE Computer Society, 2011, p. 119–129.

B. C. Lee and D. M. Brooks, “Accurate and efficient regression modeling for microarchitectural performance and power prediction,” SIGARCH Comput. Archit. News,
vol. 34, no. 5, p. 185–194, Oct. 2006. [Online]. Available: https://doi.org/10.1145/1168919.1168881
S. Kulkarni and J. Cavazos. 2012. Mitigating the compiler optimization phase-ordering problem using machine learning. ACM SIGPLAN Notices (2012). http://dl.acm.org/citation.cfm?id=2384628

Ashouri, Amir H. & Bignoli, Andrea & Palermo, Gianluca & Silvano, Cristina. (2016). Predictive Modeling Methodology for Compiler Phase-Ordering. 10.1145/2872421.2872424.

Amir H. Ashouri, Andrea Bignoli, Gianluca Palermo, Cristina Silvano, Sameer Kulkarni, and John Cavazos. 2017. MiCOMP: Mitigating the Compiler Phase-Ordering Problem Using Optimization Sub-Sequences and Machine Learning. ACM Trans. Archit. Code Optim. 14, 3, Article 29 (September 2017), 28 pages. https://doi.org/10.1145/3124452

Liu H, Luo J, Li Y and Wu Z. (2021). Iterative Compilation Optimization Based on Metric Learning and Collaborative Filtering. ACM Transactions on Architecture and Code Optimization. 19:1. (1-25). Online publication date: 31-Mar-2022.

Q. Huang, et al., "AutoPhase: Compiler Phase-Ordering for HLS with Deep Reinforcement Learning," in 2019 IEEE 27th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM), San Diego, CA, USA, 2019.
POSET-RL: https://arxiv.org/abs/2208.04238
[Wang, H. et al (4 more authors) (2022) Automating Reinforcement Learning Architecture Design for Code Optimization. In: CC 2022: Proceedings of the 31st ACM SIGPLAN International Conference on Compiler Construction. The 31st ACM SIGPLAN International Conference on Compiler Construction (CC ’22), 02-03 Apr 2022.
VenkataKeerthy, Rohit Aggarwal, Shalini Jain, Maunendra Sankar Desarkar, Ramakrishna Upadrasta, and Y. N. Srikant. 2020. IR2VEC: LLVM IR Based Scalable Program Embeddings. ACM Trans. Archit. Code Optim. 17, 4, Article 32 (December 2020), 27 pages.
Chris Cummins, Bram Wasti, Jiadong Guo, Brandon Cui, Jason Ansel, Sahir Gomez, Somya Jain, Jia Liu, Olivier Teytaud, Benoit Steiner, Yuandong Tian, and Hugh Leather. 2022. CompilerGym: robust, performant compiler optimization environments for AI research. In Proceedings of the 20th IEEE/ACM International Symposium on Code Generation and Optimization (CGO '22). IEEE Press, 92–105.
Liu et al. (2021) Hongzhi Liu, Jie Luo, Ying Li, and Zhonghai Wu. 2021. Iterative Compilation Optimization Based on Metric Learning and Collaborative Filtering. ACM Trans. Arch. Code Optim. 19, 1, Article 2 (December 2021), 25 pages. https://doi.org/10.1145/3480250
Amir H. Ashouri, Andrea Bignoli, Gianluca Palermo, Cristina Silvano, Sameer Kulkarni, and John Cavazos. 2017. MiCOMP: Mitigating the Compiler Phase-Ordering Problem Using Optimization Sub-Sequences and Machine Learning. ACM Trans. Archit. Code Optim. 14, 3, Article 29 (September 2017), 28 pages. https://doi.org/10.1145/3124452
Zavodskikh R. K., Efanov N. N., Tomashev D. D.  (2022). Using the LLVM Framework for static performance prediction with embedding of intermediate representation. Proceedings of Moscow Institute of Physics and Technology. Vol. 14, 3 (55) pp 34-45.
Tağtekin, B., Höke, B., Sezer, M. K., & Öztürk, M. U. (2021, August). FOGA: Flag Optimization with Genetic Algorithm. In 2021 International Conference on INnovations in Intelligent SysTems and Applications (INISTA) (pp. 1-6). IEEE. 
F. Agakov, E. Bonilla, J. Cavazos, B. Franke, G. Fursin, M. F. O’Boyle, J. Thomson, M. Toussaint, and C. K. Williams, “Using machine learning to focus iterative optimization,” in International Symposium on Code Generation and Optimization (CGO’06). IEEE, 2006, pp. 11–pp.
PROGRAML: A Graph-based Program Representation for Data Flow Analysis and Compiler Optimizations  (2021) https://chriscummins.cc/pub/2021-icml.pdf



