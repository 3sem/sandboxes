1) Когда мы пишем оператор throw, компилятор транслирует его в пару вызовов функций libstdc++, которые, соответственно, 
размещают исключение и начинают процесс раскручивания стека соответствующим библиотечным вызововом из libstdc.

2) Для каждого catch блока компилятор дописывает некую специальную информацию после тела метода, таблицу исключений, которые метод может отлавливать, 
а также таблицу очистки (подробнее о таблице очистки будет далее).

3) В процессе раскручивания стека вызывается специальная функция из libstdc++ (называемая "персональной подпрограммой" [personality routine]), 
которая проверяет каждую функцию в стеке на ошибки, которые она может отлавливать.

4) Если не нашлось никого, кто мог бы отловить эту ошибку, вызывается std::terminate.

5) Если кто-то все же нашелся, раскрутка запускается снова с вершины стека. 
- При этой повторной раскрутке запускается "персональная подпрограмма" по очистке ресурсов для каждого метода.
- Подпрограмма проверяет таблицу очистки для текущего метода.
- Если в методе есть, что очистить, 
подпрограмма "прыгает" в текущий фрейм стэка и запускает код очистки, который вызывает деструкторы для каждого из объектов, 
размещенных в текущей области видимости.

6) Когда раскрутка натыкается на фрагмент стека, который может обрабатывать исключение, она "прыгает" в блок обработки исключения.

7) После окончания обработки исключения, функция очистки вызывается для освобождения памяти, занятой исключением.

cxxabi -- Бинарный интерфейс С++, предоставляющий исключения средствами стандартной библиотеки.

"вся тяжелая атлетика реализована в libstdc++, определение которой дано в C++ ABI."

-------------------------------------------------------------------------------------------------------------

     -- компилятор транслирует throw объявление в пару cxa_allocate_exception/xca_throw
     -- __cxa_allocate_exception создает исключение в памяти
     -- __cxa_throw запускает работу разворачивания и передает исключение в низко-уровневую библиотеку разворачивания, вызывая _Unwind_RaiseException
    -- Разворачивание стэка использует CFI, чтобы узнать, какая сейчас функция в стеке
    -- Каждая функция имеет LSDA, добавляя что-то, называемое .gcc_except_table
    -- Разворачивание вызывает персональную функцию с текущим фреймом стэка и LSDA, которая должна продолжить разворачивать стэк, если текущая функция не имеет обработчиков исключения данного типа.


---------------------------------------------------- throw ---------------------------------------------------
`__cxa_allocate_exception(size_t)' -- выделяет достаточное количество памяти для хранения исключения во время его пробрасывания.

`__cxa_throw(void* thrown_exception,
          struct type_info *tinfo,
          void (*dest)(void*))' --  функция ответственна за вызов раскрутки стэка. Важный эффект: __cxa_throw никогда не предполагает возврат (return). Она так же передает управление подходящему catch-блок для обработки исключения либо вызывает (по-умолчанию) std::terminate, но никогда ничего не возвращает.

__class_type_info


call    __cxa_allocate_exception
    movl    $0, 8(%esp)
    movl    $_ZTI9Exception, 4(%esp)
    movl    %eax, (%esp)
    call    __cxa_throw

Summary:
    throw-объявление будет транслировано компилятором в два вызова: __cxa_allocate_exception и __cxa_throw.
    -- __cxa_allocate_exception и __cxa_throw "живут" в libstdc++.
    -- __cxa_allocate_exception выделяет память для нового исключения.
    -- __cxa_throw выполняет подготовку и отдает исключение в _Unwind, в набор функций, которые живут в libstdc и производит реальное разворачивание стэка (ABI определяет интерфейс этих функций).
    
    

-------------------------------------------------- catch --------------------------------------------
Отлов исключений требует от программы немного рефлексии (исследования своего собственного кода):

`__cxa_begin_catch'
`__cxa_end_catch'
`__gxx_personality_v0'


_Z18func_with_catch_blockv:
          .cfi_startproc
          .cfi_personality 0,__gxx_personality_v0
          .cfi_lsda 0,.LLSDA1
    
 -- Определение для функции обрезано компилятором. Это что-то новое: ссылка на __gxx_personality_v0 и что-то другое, называемое LSDA. Это выглядит незначительным определением, однако в действительности это очень важно:

-- линкер использует это для спецификации CFI (call frame information); CFI хранит информацию о фрейме вызова, вот его полная спецификация. Он используется, в основном, для раскручивания стэка.
-- LDSA (language specific data area) — специальная область для каждого языка, используемая персональной функцией, чтобы знать, какие исключения могут быть обработаны данной функцией.

[...] 
call    _Z5raisev
jmp .L8

cmpl    $1, %edx
    je  .L5

.LEHB1: # Can't handle exception
    call    _Unwind_Resume
.LEHE1:

.L5: # Can handle exception
    call    __cxa_begin_catch
    call    __cxa_end_catch
    
Тут мы проверяем — можем ли мы обрабатывать это исключение, если нет — вызываем _Unwind_Resume, если можем — вызываем __cxa_begin_catch и __cxa_end_catch, после этого функция должна продолжиться нормально и, таким образом, L8 будет выполнено (L8 прямо под нашим catch-блоком):

.L8:
    leave
    .cfi_restore 5
    .cfi_def_cfa 4, 4
    ret
    .cfi_endproc

.LFE1:
    .globl  __gxx_personality_v0
    .section    .gcc_except_table,"a",@progbits
    [...]
.LLSDACSE1:
    .long   _ZTI14Fake_Exception
    
секция .gcc_except_table — где хранится вся информация для обнаружения landing pads




    
    
 
    1) __cxa_throw/__cxa_allocate_exception создают исключение и передают их в низкоуровневую библиотеку раскрутки стэка, именуемую _Unwind_RaiseException

    2) Раскрутчик использует CFI чтобы узнать какая функция в данный момент в стэке (чтобы узнать как начинать разворачивать функцию)

    3) Каждая функция имеет LSDA-часть, добавленную во что-то, именуемое ".gcc_except_table"

    4) Раскрутчик пытается определить landing pad для исключения:

        - Раскрутчик вызывает персональную функцию с параметром action: _UA_SEARCH_PHASE и параметром context: указателем на текущий фрейм стэка.
        - Персональная функция проверяет, может ли текущий фрейм-стэк обработать это исключение, анализируя LSDA
        - Если исключение может быть обработано, она возвращает _URC_HANDLER_FOUND
        - Если исключение обрабатывать некому, будет возвращено _URC_CONTINE_UNWIND, и раскрутчик продолжит попытки найти обработчика со следующим фреймом стэка.

    5) Если ни один landing pad не найден, будет вызван обработчик по-умолчанию (обычно это std::terminate).

    6) Если landing pad найден:
        - Раскрутчик начнет обрабатывать стэк заново, вызывая персональную функцию с параметром action _UA_CLEANUP_PHASE.
        - Персональная функция проверяет: может ли текущий кадр стэка обрабатывать это исключение, или нет.
         -- Если не может, то она запускает функции очисти, описанные в LSDA, (и очищает размещенные в текущем фрейме стэка объекты вызовом деструкторов), и говорит раскрутчику продолжить со следующим фреймом.
        -- Если может обработать, тогда не запускает никакой код очистки, а лишь говорит раскрутчику, что мы хотим продолжить выполнение на такущем landing pad.


Следует обратить внимание на две важные вещи:

    1)Запуск в двух-фазном режиме отлова исключений означает, что мы можем получить оригинальный и полный stack trace исключения (если бы мы разворачивали в один проход вместе с удалением, у нас бы не было стэк-трейса, либо пришлось бы хранить его копию!).
    2)Запуская _UA_CLEANUP_PHASE и повторно вызывая для каждого фрейма, даже если мы знаем, что фрейм может обрабатывать исключение, так же очень важно: персональная функция имеет возможность вызвать все деструкторы для объектов, созданных в этой области видимости. Это то, что делает исключения RAII (Resource Acquisition Is Initialization, Получение ресурса есть инициализация) safe идиомой.



