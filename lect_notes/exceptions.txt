1) Когда мы пишем оператор throw, компилятор транслирует его в пару вызовов функций libstdc++, которые, соответственно, 
размещают исключение и начинают процесс раскручивания стека соответствующим библиотечным вызововом из libstdc.

2) Для каждого catch блока компилятор дописывает некую специальную информацию после тела метода, таблицу исключений, которые метод может отлавливать, 
а также таблицу очистки (подробнее о таблице очистки будет далее).

3) В процессе раскручивания стека вызывается специальная функция из libstdc++ (называемая "персональной подпрограммой" [personality routine]), 
которая проверяет каждую функцию в стеке на ошибки, которые она может отлавливать.

4) Если не нашлось никого, кто мог бы отловить эту ошибку, вызывается std::terminate.

5) Если кто-то все же нашелся, раскрутка запускается снова с вершины стека. 
- При этой повторной раскрутке запускается "персональная подпрограмма" по очистке ресурсов для каждого метода.
- Подпрограмма проверяет таблицу очистки для текущего метода.
- Если в методе есть, что очистить, 
подпрограмма "прыгает" в текущий фрейм стэка и запускает код очистки, который вызывает деструкторы для каждого из объектов, 
размещенных в текущей области видимости.

6) Когда раскрутка натыкается на фрагмент стека, который может обрабатывать исключение, она "прыгает" в блок обработки исключения.

7) После окончания обработки исключения, функция очистки вызывается для освобождения памяти, занятой исключением.

cxxabi -- Бинарный интерфейс С++, предоставляющий исключения средствами стандартной библиотеки.

"вся тяжелая атлетика реализована в libstdc++, определение которой дано в C++ ABI."

---------------------------------------------------- throw ---------------------------------------------------
`__cxa_allocate_exception(size_t)' -- выделяет достаточное количество памяти для хранения исключения во время его пробрасывания.

`__cxa_throw(void* thrown_exception,
          struct type_info *tinfo,
          void (*dest)(void*))' --  функция ответственна за вызов раскрутки стэка. Важный эффект: __cxa_throw никогда не предполагает возврат (return). Она так же передает управление подходящему catch-блок для обработки исключения либо вызывает (по-умолчанию) std::terminate, но никогда ничего не возвращает.

__class_type_info


call    __cxa_allocate_exception
    movl    $0, 8(%esp)
    movl    $_ZTI9Exception, 4(%esp)
    movl    %eax, (%esp)
    call    __cxa_throw

Summary:
    throw-объявление будет транслировано компилятором в два вызова: __cxa_allocate_exception и __cxa_throw.
    -- __cxa_allocate_exception и __cxa_throw "живут" в libstdc++.
    -- __cxa_allocate_exception выделяет память для нового исключения.
    -- __cxa_throw выполняет подготовку и отдает исключение в _Unwind, в набор функций, которые живут в libstdc и производит реальное разворачивание стэка (ABI определяет интерфейс этих функций).
    
    

-------------------------------------------------- catch --------------------------------------------
Отлов исключений требует от программы немного рефлексии (исследования своего собственного кода):

`__cxa_begin_catch'
`__cxa_end_catch'
`__gxx_personality_v0'




    _Z18func_with_catch_blockv:
    .cfi_startproc
    .cfi_personality 0,__gxx_personality_v0
    .cfi_lsda 0,.LLSDA1
